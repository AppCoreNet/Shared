// <auto-generated />
// Licensed under the MIT license.
// Copyright (c) The AppCore .NET project.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;
using AppCoreNet.Diagnostics;

#nullable enable

namespace AppCoreNet.Reflection;

#if !APPCORENET_SHARED_SOURCES_TESTS
[ExcludeFromCodeCoverage]
#endif
internal static class AssemblyExtensions
{
    /// <summary>
    /// Gets all types defined in the given <paramref name="assembly"/> which assignable from the specified <paramref name="type"/>.
    /// </summary>
    /// <remarks>
    /// This methods supports open generics.
    /// </remarks>
    /// <param name="assembly"></param>
    /// <param name="type"></param>
    /// <returns></returns>
    [RequiresUnreferencedCode("Types might be removed")]
    public static IEnumerable<Type> GetTypesAssignableFrom(this Assembly assembly, Type type)
    {
        Ensure.Arg.NotNull(assembly);
        Ensure.Arg.NotNull(type);

        return assembly.GetTypes()
                       .Where(
                           t => t.GetTypesAssignableFrom(true)
                                 .Contains(type));
    }

    /// <summary>
    /// Gets all exported types defined in the given <paramref name="assembly"/> which assignable from the specified <paramref name="type"/>.
    /// </summary>
    /// <remarks>
    /// This methods supports open generics.
    /// </remarks>
    /// <param name="assembly"></param>
    /// <param name="type"></param>
    /// <returns></returns>
    [RequiresUnreferencedCode("Types might be removed")]
    public static IEnumerable<Type> GetExportedTypesAssignableFrom(this Assembly assembly, Type type)
    {
        Ensure.Arg.NotNull(assembly);
        Ensure.Arg.NotNull(type);

        return assembly.GetExportedTypes()
                       .Where(
                           t => t.GetTypesAssignableFrom(true)
                                 .Contains(type));
    }
}